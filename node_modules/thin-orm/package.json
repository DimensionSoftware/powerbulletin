{
  "name": "thin-orm",
  "version": "0.1.4",
  "description": "An object relational mapper for SQL databases",
  "main": "main",
  "scripts": {
    "test": "nodeunit test"
  },
  "devDependencies": {
    "nodeunit": "0.7.x",
    "async": "0.1.x",
    "pg": "0.8.x",
    "sqlite3": "2.1.x"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/on-point/thin-orm.git"
  },
  "keywords": [
    "database",
    "orm",
    "postgres",
    "postgresql",
    "sqlite",
    "sqlite3",
    "sql"
  ],
  "author": {
    "name": "Steve Hurlbut",
    "email": "steve@onpointapplications.com"
  },
  "license": "MIT",
  "readme": "# thin-orm\n\nThin-orm is a lightweight Object Relational Mapper (ORM). Thin-orm provides you with a\nmongodb inspired API for accessing your favorite SQL database.\n\nThe _thin_ in thin-orm means that very little additional processing is done; your queries will run\njust about as fast as if you had written them in native SQL.\n\nThin-orm sits on top of a node client for your database. It has built in support for the following clients:\n\n* postgresql: [node-postgres (pg)](https://github.com/brianc/node-postgres)\n* sqlite3: [node-sqlite3](https://github.com/developmentseed/node-sqlite3)\n\nIf your SQL database is not listed here, don't worry. Interfacing to a node database driver is\nreally easy. Take a look at the examples in the drivers directory.\n\n\n## Installation\n\n```bash\nnpm install thin-orm\nnpm install pg        #  required for postgres\nnpm install sqlite3   #  required for sqlite3\n```\n\n## Overview\n\nBefore you can start executing queries, you need to define your tables using thin-orm's fluent\ninterface. The minimal configuration is shown here:\n\n```js\nvar orm = require('thin-orm'),\n\norm.table('users')\n   .columns('id', 'login', 'firstName', 'lastName', 'createdAt');\n```\n\nNow we are ready to create a client driver connection and run queries:\n\n```js\nvar sqlite3 = require('sqlite3').verbose(),\n    db = new sqlite3.Database(':memory:'),\n    driver = orm.createDriver('sqlite', { db: db }) }),\n    userClient = ORM.createClient(driver, 'users');\n\nuserClient.create({ data: { login: 'joe', firstName: 'Joe', lastName: 'Smith'}}, callback);\n// callback result: { id: 1 }\n\nuserClient.findMany({ criteria: { firstName: 'Joe' }, callback)\n// callback result: { count: 1, rows: \\[ { id: 1, login: \"joe\", firstName: \"Joe\", lastName: \"Smith\" } \\] }\n\nuserClient.update({ criteria: { id: 1 }, data: { firstName: 'Joseph' }}, callback)\n// updates row with id == 1\n\nuserClient.remove(1, callback)\n// deletes row with id == 1\n```\n\nYou can see a working example of thin-orm in the [sample web app](https://github.com/on-point/nodecellar).\n\n## Features\n\n* filtering\n* sorting\n* paging (maximum rows and row offset)\n* joins\n* optionally maps javascript camelcase names to database names (e.g. `firstName` to `first_name`)\n* helps protect against SQL injection attacks\n\n## Filtering\n\n#### Fetching a single record\n\nYou can fetch a single row from a database table using the primary index:\n\n```js\nuserClient.findById(1, callback)\n// callback result: { id: 1, login: \"joe\", firstName: \"Joe\", lastName: \"Smith\" }\n```\n\nOr using criteria that uniquely identifies a row:\n\n```js\nuserClient.findOne({ criteria: { firstName: 'Joe', lastName: 'Smith' } }, callback)\n// callback result: { id: 1, login: \"joe\", firstName: \"Joe\", lastName: \"Smith\" }\n```\n\n#### Fetching a multiple records\n\nA *criteria* object specifies the filter that is applied to the rows in a table.\n\nA simple equality filter:\n\n```js\nuserClient.findMany({ criteria: { firstName: 'Joe' } }, callback)\n// callback result: { count: 2, rows: \\[ { id: 1, login: \"joe\", firstName: \"Joe\", lastName: \"Smith\" }\n//                                       { id: 16, login: \"joep\", firstName: \"Joe\", lastName: \"Peters\" } \\] }\n```\n\nYou can use the operators LT (less than), LTE (less than or equal), GT (greater than), GTE (greater than or equal),\nNE (not equal) and LIKE (wild card match) as part of your criteria:\n\n```js\nuserClient.findMany({ criteria: { id: { LT: 3 } } }, callback)\n// callback result: { count: 2, rows: \\[ { id: 1, login: \"joe\", firstName: \"Joe\", lastName: \"Smith\" }\n//                                       { id: 2, login: \"mary\", firstName: \"Mary\", lastName: \"Katz\" } \\] }\n```\n\n#### Sorting\n\nYou can sort the rows returned by the query.\n\n```js\nuserClient.findMany({ criteria: { firstName: { LIKE: { 'J%' }}}, sort: { lastName: \"DESC\" }}, callback);\n// callback result: { count: 2, rows: \\[ { id: 1, login: \"joe\", firstName: \"Joe\", lastName: \"Smith\" }\n//                                       { id: 16, login: \"joep\", firstName: \"Joe\", lastName: \"Peters\" } \\] }\n```\n\nIf you need to sort on multiple columns, you can pass an array of sort criteria with the primary sort\ncolumn listed first.\n\n```js\nuserClient.findMany({ sort: [ { lastName: \"ASC\" }, { firstName: \"ASC\" } ] }, callback);\n// callback result: { count: 211, rows: \\[ { id: 21, login: \"sama\" , firstName: \"Sam\", lastName: \"Abrams\" }\n//                                       { id: 116, login: \"trevora\", firstName: \"Trevor\", lastName: \"Abrams\" }\n//                                       ...                                                                    \\] }\n```\n\n#### Paging\n\nThin-orm supports a maximum number of rows to return and an offset into the result set at\nwhich to begin counting. So the following query will return rows 60 to 80 of the result set.\nNote that you should always sort the results if you are using an offset.\n\n```js\nwidgetClient.findMany({ sort: { itemId: \"ASC\" }, offset: 60, limit: 20 }, callback);\n// callback result: { count: 20, rows: \\[ { itemId: 1267, name: \"super deluxe widget\", price: 24.99 }\n//                                       { itemId: 1288, name: \"average ordinary widget\", price: 14.99 }\n//                                       ...                                                                    \\] }\n```\n\n#### Joins\n\nOne-to-one and one-to-many joins are supported by thin-orm. In a one-to-one join, columns from the join\ntable are promoted into the array of objects returned by the query. However, in a one-to-many\njoin, the columns of the join table become child objects of each object returned.\n\nAll joins need to be defined when you define the table. A join can be specified as a \"default\" join; these\njoins will automatically be added to all queries against the table.\n\nCurrently, you cannot nest joins.\n\nHere are some examples:\n\n```js\norm.table('users')\n   .columns('id', 'login', 'firstName', 'lastName', 'createdAt');\norm.table('blogs')\n   .columns('id', 'userId', 'text', 'createdAt')\n   .join('comments').oneToMany('comments').on({ id: 'blogId' })\n   .join('login').oneToOne('users').on({ userId: 'id' }).columnMap({ name: 'login' });\norm.table('comments')\n   .columns('id', 'userId', 'blogId', 'text', 'createdAt'])\n   .join('login').oneToOne('users').on({ userId:'id' }).columnMap({ name:'login' }).default();\n\nblogClient.findMany({ criteria:{ userId: 1 }, joins: \\[ 'login' \\] }, callback);\n// callback result: { count: 2, rows: \\[\n//      { id: 1, userId: 1, text: 'some blog text', createdAt: 1352576196772, name: 'joe' }\n//      { id: 7, userId: 1, text: 'another blog text', createdAt: 135257633821, name: 'joe' }\n//  \\] }\n// (note that the `name: 'joe'` field was added from the `login` column of the `users` table)\n\nblogClient.findMany({ criteria:{ userId:1 }, joins: \\[ 'comments' \\] }, callback);\n// callback result: { count: 3, rows: \\[\n//      { id: 1, userId: 3, text: \"blog text 1\", createdAt: \"2012-11-22T00:00:00.000Z\", name : \"samuel\", comments:\\[\n//            { id: 2, userId:2, blogId: 1, text: \"you must be kidding\", createdAt: \"2012-11-22T00:00:00.000Z\"}\n//      \\]}, ...\n```\n\n## Integration with HTTP servers\n\nIf you wish, thin-orm can automatically send a JSON response to a REST request. Instead of passing a callback\nfunction as the last response, pass in a response object. If the response object has a `send` method, then\nthin-orm will call that method with the result rows. The data returned to the caller wil be:\n\n* `findById` or `findOne` will return a single object\n* `findMany` will return an array of JSON objects\n* `create` will return an object with an `id` field set to the id of the new record\n* `delete` or `update` will return an HTTP 200 code if successful, 500 if it fails\n\n## License\n\nMIT\n\n",
  "readmeFilename": "README.md",
  "_id": "thin-orm@0.1.4",
  "dist": {
    "shasum": "6570542e9b382a09b75dd2a0f1b4f561fea4b14a"
  },
  "_from": "thin-orm"
}
