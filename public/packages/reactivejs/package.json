{
  "name": "reactivejs",
  "version": "0.0.0",
  "description": "A library for programming reactively in Javascript.",
  "main": "src/reactive.js",
  "scripts": {
    "test": "node src-test/node.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mattbaker/Reactive.js"
  },
  "keywords": [
    "reactive"
  ],
  "author": {
    "name": "Matt Baker"
  },
  "license": "Apache 2.0",
  "readme": "#Reactive.js\n##A (really) short intro\nReactive.js will augment (\"reactify\") a given Javascript function so that it may track dependencies on other reactive functions. You might think of a reactive function as representing a cell in a spreadsheet. Spreadsheet cells can reference each other, depend on each other, and cells update their values automatically when one of their dependent cells change. Reactive functions can do this too. To be clear, they're still Javascript functions, just with a little \"extra\".\n\n\n##Reactive Programming in 60 seconds\n\nIn Reactive programming it's easier to think of our variables as _expressions_, not as _assignments_. In order to understand the difference, consider the statement \"`a = b + c`\".\n\nThere are two ways to look at this. One is the way we are used to, _\"`a` is **assigned to** the sum of `b` and `c`, at the instant this is interpreted\"_, which is what we'd expect in Javascript or any other imperative language.\n\nBut we could also read it as _\"`a` **represents** the sum of `b` and `c`, at any point in time.\"_ This interpretation is not really so strange, that's exactly how we would expect things to work in a spreadsheet. If we had a spreadsheet cell containing the expression  \"`=B+C`\", the value in that cell would change as the cells B and C change, wouldn't it?\n\nReactive programming means we describe our program using the second interpretation. We don't assign variables, we _express_ them, and they don't represent discrete values, they represent a value that _changes over time_.\n\n##Reactive programming in Javascript\nObviously Javascript is not a reactive language, but there are advantages to being able to express ourselves reactively. Reactive programming can be immensely useful in describing systems of equations, complicated UIs, and data visualizations to name a few.\n\nSo let's reexamine our earlier statement about reactive programming, then we'll see how Javascript fits into the picture (and how Reactive.js fits into Javascript).\n\n> \"We don't assign variables, we _express_ them...\"\n\nIn Javascript, `a = b + c` assigns a _value_. For us to accomplish our goal, however, we need to describe what `a` represents using an **expression** (like `=B+C` in a spreadsheet). Javascript *does* have expressions, they're called functions! So in reactive programming a given value, like `a` in `a = b + c` is expressed as a function:\n\n```javascript\n\tvar a = function (b,c) { return b + c } // a = b + c\n```\n\nThis brings us to our first conclusion.\n\n### Conclusion 1: Our variables are expressions, so our variables are functions.\n\nNow lets consider the rest of the sentence:\n> \"…and they don't represent discrete values, they represent a value that _changes over time_\"\n\nWhen you write `=B+C` in a spreadsheet, your spreadsheet program notes that your cell is relying on the values of B and C. It starts to assemble a dependency graph internally that it can use to keep track of changes. It traverses that graph when B or C change, updating A in the process. Most importantly, we don't have to write a \"calculate all\" function because the spreadsheet program handles that for us.\n\nUnfortunately Javascript won't magically track dependencies, so it's not enough to describe our variables as expressions, we also need to tell our expressions what they _depend_ on. Only then can they be smart enough to update each other automatically\n\n### Conclusion 2: We have to tell our expressions what they depend on.\n\nWhen we combine our two conclusions, we arrive at the following:\n\n> Our variables are expressions, so our variables are **functions**. And we have to tell our expressions what they depend on, so that means **we have to tell our functions what they depend on**.\n\nFortunately for you, Reactive.js does just that.\n\n\n##Using Reactive.js\n\nAt its core, Reactive.js is just a single method, `$R()`. `$R()` accepts a function and returns you an augmented version of that function that is meant to represent a value in your program. How is it augmented exactly? \"Reactive functions\" gain a new method called `.bindTo()`. `bindTo()` accepts one or more reactive functions, and binds them to your function's arguments via partial application.\n\nDon't worry about $R.state yet, it just returns a reactive function that gets and sets internal state (handy for literal values) — more on that later.\n\n\n```javascript\n\t//A = B + C\n\tvar reactiveA = $R(function (b, c) { return b + c });\n\tvar reactiveB = $R.state(2);\n\tvar reactiveC = $R.state(1);\n\treactiveA.bindTo(reactiveB, reactiveC);\n\n\treactiveA();   //-> 3\n\treactiveB(5);  //Set reactiveB to 5\n\treactiveC(10); //Set reactiveC to 10\n\treactiveA();   //-> 15\n```\n\nThat's it. As you can see, Reactive.js asks you to _express values as functions_ and gives you the tools you need to _tell those functions how they depend on each other_. In the example above, any time `reactiveA` or `reactiveB` change, `reactiveC` will change too. `reactiveC` isn't assigned `a+b`, it _represents_ `a+b` at any moment in time.\n\n###An example with time\n\nSince we talk about variables representing a value that changes over time, let's actually create variables that depend on, well, a value that changes over time.\n\n```javascript\n\tvar now = $R(function (date) { return date });\n\n\t//Update \"now\" every millisecond\n\tsetInterval(function () { now(new Date) }, 1);\n\n\tvar currentMillisecond = $R(function (date) {\n\t\treturn date.getMilliseconds() ;\n\t}).bindTo(now);\n\n\tvar dayOfTheWeek = $R(function (date) {\n\t\tvar days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];\n\t\treturn days[date.getDay()];\n\t}).bindTo(now);\n\n\tvar isItSunday = $R(function (day) {\n\t\treturn day === 'Sun';\n\t}).bindTo(dayOfTheWeek);\n```\n\nWe can log out any of our reactive variables at any time and we'll see that they're staying current as the value of `now` is updated.\n\n```javascript\n\tconsole.log(currentMillisecond()); //-> 700\n\tconsole.log(currentMillisecond()); //-> 800\n\tconsole.log(currentMillisecond()); //-> 900\n\tconsole.log(dayOfTheWeek()); //-> Thu\n\tconsole.log(isItSunday()); //-> false\n\n\t//And that Sunday...\n\tconsole.log(currentMillisecond()); //-> 400\n\tconsole.log(dayOfTheWeek()); //-> Sun\n\tconsole.log(isItSunday()); //-> true\n```\n\n###Values-as-functions are purely conceptual\nNot every value in your code is represented as something you can return. As one example, we can still think of the content of the div in the following example as a single value:\n\n```html\n\t<div id=\"time\"></div>\n```\n\n```javascript\n\tvar timeDivContents = $R(function (now) {\n\t\t$(\"#time\").html(now.toString());\n\t}).bindTo(now);\n```\n\nWe didn't create a function that \"updates the contents of the time div\", we're saying this function _represents_ the contents of the time div. As the setInterval statement updates \"now\" every millisecond our div will update too, all on its own.\n\n###Reactive.js is minimal\nReactive.js seeks to be as minimal and unobtrusive as possible. Because it operates on, and returns, normal Javascript functions, it's _very_ easy to integrate into existing code. If you start writing \"reactive\" code, any existing function can be integrated as a dependency by creating a reactive version of it with `$R()`.\n\n##Reactive.js API\n####$R(_function[, context]_) &#10145; _ReactiveFunction_\n`$R()` takes a function and optional context. If supplied a context, Reactive.js will ensure that your function runs with `this` bound to `context`.\n\n`$R()` returns a new function that is functionally identical, but with augmentation. In short, `$R()` returns a \"reactified\" version of your function, giving it the ability to participate in the dependency graph of reactive values in your application. A reactive function may bind (via `.bindTo()`) its arguments to other reactive functions, and vice versa.\n\n```javascript\n\t//Unbound reactive functions are functionally identical\n\tvar sum = function (a,b) { return a + b };\n\tvar reactiveSum = $R(sum);\n\treactiveSum(1,2); //-> 3\n```\n\n####rFnc.**bindTo**(_ReactiveFunction_,…) &#10145; _rFnc_\nWhen you supply a function to `$R()` it returns a new function with the addition of a **`bindTo()`** method. `bindTo()` takes one or more reactive functions as its arguments. The provided functions are bound to the arguments in your function (partial application). When those functions' values update they will be passed as the arguments to your function, which will re-calculate itself (and pass its value to any other functions that depend on _it_ in turn).\n\n```javascript\n\tvar x = $R(function (n) { return n });\n\tvar x2 = $R(function (x) { return x * x }).bindTo(x);\n\n\tx(2);\n\tx2(); //->4\n\tx(4);\n\tx2(); //->16\n```\n\n`bindTo()` can also accept literal values. It will bind them as you would expect:\n\n```javascript\n\tvar greet = $R(function (name) {\n\t\treturn \"Hello \"+ name\n\t}).bindTo(\"Jane\");\n\tconsole.log(greet()); //-> \"Hello Jane\"\n```\n\n`bindTo()` can accept a mix of literals and reactive functions.\n\n####$R._\n`$R._` is a special value that represents a \"gap\" when binding up the arguments in your reactive function. For example, if we want to bind the *first* and *third* arguments of a function, but *not* the second, we would say:\n\n```javascript\n\tvar reactiveFnc = $R(function (a,b,c) { return a + b + c });\n\treactiveFnc.bindTo(myA, $R._, myC);\n```\n\nWe bound `a` and `c` in our reactive function to `myA` and `myC`, so now `reactiveFnc` only accepts  one argument, the argument for `b`.\n\n####$R.state(_initial_) &#10145; _ReactiveFunction_\n\nSince Reactive.js uses functions, not variables, to represent values, it's helpful to have a concise way to represent state. `$R.state` returns a reactive function that gets and sets internal state.\n\nIf you call the function without an argument, it simply returns the currently saved value. If you provide an argument, the reactive function will store that argument as its new state value. This is how you'd replace `var a` with `$R.state()`:\n\n```javascript\n\t//With var\n\tvar a = 3;\n\tconsole.log(a); //->3\n\ta = 4;\n\tconsole.log(a); //->4\n\n\t//With $R.state\n\tvar a = $R.state(3);\n\tconsole.log(a()); //->3\n\ta(4)\n\tconsole.log(a()); //->4\n```\n\n`$R.state` is a convenient way to represent reactive values in your application that will only change by assignment (much like typing a literal number into a spreadsheet composed of many calculations).\n\nThe function returned by $R.state is, of course, reactive. They can bind to, and be bound to, other reactive functions.\n\n\n##Notes on internals\nThere are a few things to throw out there for the curious:\n\n###Values are cached\nReactive functions cache their values when they are executed. Consider a function X that depends on functions Y and Z (which have already run). If we run function X if will ask for the values of it dependencies X and Y, however _X and Y will not be run because they have not changed_. This is important for large systems of interdependent reactive functions. And, of course, if a dependency's value changes its cached value is updated and any downstream dependent values will execute and update their cached values too.\n\n###Functions are not evaluated redundantly\nReactive.js performs a topological sort of the dependency graph, meaning it assembles a list of functions to evaluate in-order. Reactive.js is smart enough to ensure that a function, even if it is a dependency for several others, will only be executed once.\n\n###Dependency graph traversal is recursive\nIn a worst case scenario, with a chain of dependent nodes thousands in number, we can exceed the size of the call stack. You'd *really* have to try at this to do it, but the limitation is out there. If it's truly an issue the traversal function can be swapped for a loop in the future.\n\n###State is tough\nState doesn't fit into the whole \"functional reactive\" paradigm very neatly. Simple operations like incrementing a $R.state value by one would require two graph traversals, e.g. `myVal(myVal() + 1)`. As Reactive.js matures, we'll finds better ways to address these problems.\n\n##Where is it being used?\n\n * [Wealthfront.com](https://www.wealthfront.com/plan?values=6%7C50000%7C8%7C8.0%7C25%7C50000%7C100000%7CS%7Cfalse%7Cfalse%7CD%7Cgain%7CkeepAll%7CB), managing visualizations, calculations and UI synchronization\n",
  "_id": "reactivejs@0.0.0",
  "dist": {
    "shasum": "f5f8e600357037956f6e8d1bbfe1ae09a30e2528"
  },
  "_from": "git://github.com/mattbaker/Reactive.js.git"
}
